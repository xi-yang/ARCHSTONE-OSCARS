/* Type converter between soapclasses and Hibernate beans.
 *
 * @author David Robertson, Mary Thompson, Jason Lee
 */
package net.es.oscars.resourceManager.http;

import java.util.*;

import org.apache.log4j.*;

// code generated by Martin Swany's schemas
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneDomainContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneHopContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneLinkContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneNodeContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePathContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePortContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwcapContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfo;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfoPsc;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfoL2Sc;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfoTdm;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfoLsc;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfoOpenflow;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwcapVendorSpecificInfo;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneAdcapContent;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.JAXBElement;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import javax.xml.transform.dom.*;
import org.w3c.dom.*;
import java.io.StringWriter;
import java.io.StringReader;

//import net.es.oscars.resourceManager.beans.*;
import net.es.oscars.resourceManager.beans.ConstraintType;
import net.es.oscars.resourceManager.beans.Layer2Data;
import net.es.oscars.resourceManager.beans.Layer3Data;
import net.es.oscars.resourceManager.beans.MPLSData;
import net.es.oscars.resourceManager.beans.OptConstraint;
import net.es.oscars.resourceManager.beans.Path;
import net.es.oscars.resourceManager.beans.PathElem;
import net.es.oscars.resourceManager.beans.PathElemParam;
import net.es.oscars.resourceManager.beans.PathElemParamSwcap;
import net.es.oscars.resourceManager.beans.PathElemParamType;
import net.es.oscars.resourceManager.beans.PathType;
import net.es.oscars.resourceManager.beans.Reservation;
import net.es.oscars.resourceManager.beans.StdConstraint;
//import net.es.oscars.resourceManager.common.GlobalParams;
import net.es.oscars.resourceManager.common.RMCore;
import net.es.oscars.resourceManager.common.RMException;
import net.es.oscars.resourceManager.common.URNParser;
import net.es.oscars.resourceManager.dao.PathElemDAO;
import net.es.oscars.resourceManager.dao.PathElemParamDAO;
import net.es.oscars.api.soap.gen.v06.Layer2Info;
import net.es.oscars.api.soap.gen.v06.Layer3Info;
import net.es.oscars.api.soap.gen.v06.MplsInfo;
import net.es.oscars.api.soap.gen.v06.OptionalConstraintType;
import net.es.oscars.api.soap.gen.v06.OptionalConstraintValue;
import net.es.oscars.api.soap.gen.v06.PathInfo;
import net.es.oscars.api.soap.gen.v06.ReservedConstraintType;
import net.es.oscars.api.soap.gen.v06.UserRequestConstraintType;
import net.es.oscars.api.soap.gen.v06.VlanTag;

//import net.es.oscars.api.soap.gen.v06.*;

/**
 * Has methods to convert between  WSDL type classes and Hibernate beans.
 * Used by both the ResourceManager and the WBUI.
 */
public class WSDLTypeConverter {

    final public static String DEFAULT_TE_METRIC = "10";
    final public static String DEFAULT_SWCAP = PathElemParamSwcap.MPLS;
    final public static String DEFAULT_ENCODING = "ethernet";
    private static Logger log = Logger.getLogger(WSDLTypeConverter.class);

    // do not instantiate
    private WSDLTypeConverter() {
    }
    /**
     * convert from UserRequestConstraintType soap class to StdConstraint hibernate bean.
     * 
     * @param uc UserRequestConstraintType
     * @return StdConstraint object
     * @throws RMException
     */
    public static StdConstraint userRequest2StdConstraint(UserRequestConstraintType uc)  throws RMException {
        //log.debug("userRequest2StdConstraint:start");
        StdConstraint sc = new StdConstraint();
        sc.setConstraintType(ConstraintType.USER);
        sc.setStartTime(uc.getStartTime());
        sc.setEndTime(uc.getEndTime()); 
        Long bandwidth = new Long(Long.valueOf((long)uc.getBandwidth() * 1000000L));
        sc.setBandwidth( bandwidth );
        Path reqPath = pathInfo2Path( uc.getPathInfo());
        sc.setPath(reqPath);
        //log.debug("userRequest2StdConstraint:end");

        return sc;
    }
 
    /**
     * update a StdConstraint hibernate bean from UserRequestConstraintType soap class .
     * 
     * @param sc StdConstraint hibernate bean to be updated
     * @param uc UserRequestConstraintType new values
     * @param dbname String name of the database being referenced, different for unit tests and real service
     * @throws RMException
     */
    public static void updateStdConstraint (StdConstraint sc, UserRequestConstraintType uc,
            String dbname) throws RMException {
        //log.debug("updateStdConstraint.start userConstraint");
        sc.setConstraintType(ConstraintType.USER);
        if ( uc.getStartTime() != 0 ) {
            sc.setStartTime(uc.getStartTime());
        }
        if (uc.getEndTime() != 0){
            sc.setEndTime(uc.getEndTime()); 
        }
        Long bandwidth = new Long(Long.valueOf((long)uc.getBandwidth() * 1000000L));
        if (bandwidth != 0) {
            sc.setBandwidth( bandwidth );
        }
        if (uc.getPathInfo() != null) {
            Path reqPath = sc.getPath();
            if (reqPath == null) {
                reqPath = pathInfo2Path( uc.getPathInfo());
                sc.setPath(reqPath);
            } else {
                updatePath (reqPath, uc.getPathInfo(),dbname);
            }
        }
        //log.debug("updateStdConstraint.end userConstraint");
    }
    
    /**
     * update a StdConstraint hibernate bean from ReservedConstraintType soap class .
     * 
     * @param sc StdConstraint hibernate bean to be updated
     * @param rc ReservedConstraintType new values
     * @param dbname String name of the database being referenced, different for unit tests and real service
     * @throws RMException
     */
    public static void updateStdConstraint (StdConstraint sc, ReservedConstraintType rc,
            String dbname) throws RMException {
        //log.debug("updateStdConstraint.start  reservedConstraint");
        sc.setConstraintType(ConstraintType.RESERVED);
        if (rc.getStartTime() != 0){
            sc.setStartTime(rc.getStartTime());
        }
        if (rc.getEndTime() != 0) {
            sc.setEndTime(rc.getEndTime()); 
        }
        Long bandwidth = new Long(Long.valueOf((long)rc.getBandwidth() * 1000000L));
        if (bandwidth != 0){
            sc.setBandwidth( bandwidth );
        }
        if (rc.getPathInfo() != null ){
            Path reqPath = sc.getPath();
            if (reqPath == null) {
                reqPath= pathInfo2Path( rc.getPathInfo());
                sc.setPath(reqPath);
            } else {
                updatePath (reqPath, rc.getPathInfo(),dbname);
            }
        }
        //log.debug("updateStdConstraint.end reservedConstraint");

    }

    /**
     * convert from StdConstraint hibernate bean to UserRequestConstraintType soap class to 
     * @param sc StdConstraint object
     * @param internalPathAuthorized b true if requester is allowed to see internal hops
     * @param localDomainName String used to determine local hops
     * @return UserRequestConstraintType
     * @throws RMException
     */
    public static UserRequestConstraintType stdConstraint2UserRequest( StdConstraint sc,
            boolean internalPathAuthorized,String localDomainName)  throws RMException {
        UserRequestConstraintType uc = new UserRequestConstraintType();
        if (!sc.getConstraintType().equals(ConstraintType.USER)) {
            throw new RMException("Constraint not USER type");
        }
        uc.setStartTime(sc.getStartTime());
        uc.setEndTime(sc.getEndTime()); 
        Long mbps = sc.getBandwidth() / 1000000L; 
        int bandwidth = mbps.intValue();
        uc.setBandwidth( bandwidth );
        //Path path = sc.getPath(PathType.PRIMARY);
        Path path = sc.getPath();
        PathInfo pathInfo = null;
        if (path != null) {
            pathInfo = path2PathInfo(sc, path,
                internalPathAuthorized,localDomainName);
        } else {   //only happens with legacy reservations where the requested path was not saved
                   // keep UserRequestContraint from violating the schema
            pathInfo = new PathInfo();
            pathInfo.setPathSetupMode("invalid");
        }
        uc.setPathInfo(pathInfo);
        return uc;
    }
    /**
     * convert from ReservedConstraintType soap class to StdConstraint hibernate bean.
     * 
     * @param rc UserRequestConstraintType
     * @return StdConstraint object
     * @throws RMException
     */
    public static StdConstraint reserved2StdConstraint(ReservedConstraintType rc)  throws RMException {
        //log.debug("reservedRequest2StdConstraint:start");
        StdConstraint sc = new StdConstraint();
        sc.setConstraintType(ConstraintType.RESERVED);
        sc.setStartTime(rc.getStartTime());
        sc.setEndTime(rc.getEndTime()); 
        Long bandwidth = new Long(Long.valueOf((long)rc.getBandwidth() * 1000000L));
        sc.setBandwidth( bandwidth );
        Path reqPath = pathInfo2Path( rc.getPathInfo());
        sc.setPath(reqPath);
        //log.debug("reservedRequest2StdConstraint:end");
        return sc;
    }
    /**
     * convert from StdConstraint hibernate bean to ReservedConstraintType soap class to 
     * @param sc StdConstraint object
     * @param internalPathAuthorized b true if requester is allowed to see internal hops
     * @param domainName String used to determine local hops
     * @return ReservedConstraintType
     * @throws RMException
     */

    public static ReservedConstraintType stdConstraint2ReservedConstraint( StdConstraint sc,
            boolean internalPathAuthorized, String domainName )  throws RMException {
        ReservedConstraintType rc = new ReservedConstraintType();
        if (!sc.getConstraintType().equals(ConstraintType.RESERVED)) {
            throw new RMException("Constraint not RESERVED type");
        }
        rc.setStartTime(sc.getStartTime());
        rc.setEndTime(sc.getEndTime()); 
        Long mbps = sc.getBandwidth() / 1000000L; 
        int bandwidth = mbps.intValue();
        rc.setBandwidth( bandwidth );
        PathInfo path = path2PathInfo(sc, sc.getPath(),internalPathAuthorized, domainName);
        if (path != null){
            rc.setPathInfo(path);
        }
        /*
        } else { // no path saved, should not happen
            throw new RMException("No path saved for reservation");
        }
        */
        return rc;
    }
    
    public static OptConstraint OptionalConstraintType2OptConstraint(OptionalConstraintType oct) {
        OptConstraint oc = new OptConstraint();

        oc.setConstraintType("String");
        oc.setKeyName(oct.getCategory());
        Object value = oct.getValue().getStringValue();
        oc.setValue(value.toString());
        
        return oc;
    }
    
    /*@S bhr*/
    
    public static OptionalConstraintType OptConstraint2OptionalConstraintType(OptConstraint oc) {
   
    	OptionalConstraintType oct = new OptionalConstraintType();
    	OptionalConstraintValue ocv = new OptionalConstraintValue();
    	
    	oct.setCategory(oc.getKeyName());
    	ocv.setStringValue(oc.getValue());
        
    	oct.setValue(ocv);
    	
        return oct;
    }
    
    /*@E bhr*/
    
    /**
     * Converts an incoming soap PathInfo object into a Hibernate Path object.
     *
     * @param pathInfo PathInfo instance (soap type) with filled in info
     * @return path Path in database format
     */
    public static Path pathInfo2Path(PathInfo pathInfo) throws RMException {

        //log.debug("pathInfo2Path.start");
        Path path = new Path();
        if (pathInfo.getPathType() != null) {
            path.setPathType(pathInfo.getPathType());
        } else {
            path.setPathType(PathType.LOOSE);
        }
        path.setPathSetupMode(pathInfo.getPathSetupMode());
        Layer2Info layer2Info = pathInfo.getLayer2Info();
        Layer3Info layer3Info = pathInfo.getLayer3Info();
        MplsInfo mplsInfo = pathInfo.getMplsInfo();
        if (layer2Info != null) {
            Layer2Data dbLayer2Data = layer2InfoToData(layer2Info);
            path.setLayer2Data(dbLayer2Data);
        } else if (layer3Info != null) {
            Layer3Data dbLayer3Data = layer3InfoToData(layer3Info);
            path.setLayer3Data(dbLayer3Data);
        }
        if (mplsInfo != null) {
            MPLSData dbMplsData = mplsInfoToData(mplsInfo);
            path.setMplsData(dbMplsData);
        }
        
        List<PathElem> pathElems = new ArrayList<PathElem>();
        CtrlPlanePathContent requestedPath = pathInfo.getPath();
        if ((requestedPath == null) || (requestedPath.getHop() == null)) {
            if (layer2Info != null) {
                // If no explicit path for layer 2, we must fill this in
                PathElem srcpe = addDefaultPathElem(layer2Info.getSrcEndpoint(),
                                                    layer2Info.getSrcVtag());
                PathElem dstpe = addDefaultPathElem(layer2Info.getDestEndpoint(),
                                                    layer2Info.getDestVtag());
                pathElems.add(srcpe);
                pathElems.add(dstpe);
            }
            path.setPathElems(pathElems);
            //log.debug("pathInfo2Path.end");
            return path;
        }
        
        List<CtrlPlaneHopContent> hops = requestedPath.getHop();
        //for (CtrlPlaneHopContent hop : hops) {
        for ( Iterator<CtrlPlaneHopContent> hopIter = hops.iterator(); hopIter.hasNext();){
            CtrlPlaneHopContent hop = hopIter.next();
            PathElem pathElem = new PathElem();
            CtrlPlaneLinkContent link = hop.getLink();
            if (link != null) {
                List<PathElemParam> pathElemParams =
                    convertCtrlPlaneLink(link);
                for (PathElemParam pep: pathElemParams) {
                    pathElem.addPathElemParam(pep);
                }
            }else if ((hopIter.hasNext() == false)  && layer2Info != null &&
                    layer2Info.getDestVtag() != null){
                /* if last hop is a linkIdRef then copy
                   dest VLAN params. This is for compatibility
                   with 0.4 */
                PathElemParam pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(PathElemParamSwcap.L2SC);
                pathElemParam.setType(PathElemParamType.L2SC_VLAN_RANGE);
                // I changed the following code to correspond to the new fields in vlanTag- mrt
                pathElemParam.setValue(layer2Info.getDestVtag().isTagged() ?
                        layer2Info.getDestVtag().getValue() : "0");
                pathElem.addPathElemParam(pathElemParam);
            }
            String urn = hopToURN(hop, "any");
            pathElem.setUrn(urn);
            pathElems.add(pathElem);
        }
        path.setPathElems(pathElems);
        //log.debug("PathInfo2Path.end");
        return path;
    }
 
    /**
     * Update a Hibernate Path object from a soap PathInfo object.
     * @param path Path in database format to be updated
     * @param pathInfo PathInfo instance (soap type) with filled in info
     * @param dbname String name of the database being referenced, different for unit tests and real service
     */
    public static void updatePath (Path path, PathInfo pathInfo, String dbname) throws RMException {

        //log.debug("updatePath.start");
        if (pathInfo == null) {
            return;
        }
        if (pathInfo.getPathType() != null) {
            path.setPathType(pathInfo.getPathType());
        }
        if (pathInfo.getPathSetupMode() != null ) {
            path.setPathSetupMode(pathInfo.getPathSetupMode());
        }
        Layer2Info layer2Info = pathInfo.getLayer2Info();
        Layer3Info layer3Info = pathInfo.getLayer3Info();
        if (layer2Info != null) {
            Layer2Data dbLayer2Data = path.getLayer2Data();
            if (dbLayer2Data != null) {
                updateLayer2Data(dbLayer2Data, layer2Info);
            } else {
                dbLayer2Data = layer2InfoToData(layer2Info);
            }
            path.setLayer2Data(dbLayer2Data);
        } else if (layer3Info != null){
            Layer3Data dbLayer3Data = layer3InfoToData(layer3Info);
            if (dbLayer3Data != null) {
                updateLayer3Data(dbLayer3Data,layer3Info);
            } else {
                dbLayer3Data = layer3InfoToData(layer3Info);
                path.setLayer3Data(dbLayer3Data);
            }
        }
        MplsInfo mplsInfo = pathInfo.getMplsInfo();    
        if (mplsInfo != null) {
            MPLSData dbMplsData = path.getMplsData();
            if (dbMplsData != null){
                updateMplsData(dbMplsData,mplsInfo);
            } else {
                dbMplsData = mplsInfoToData(mplsInfo);
            }
            path.setMplsData(dbMplsData);
        }
        CtrlPlanePathContent requestedPath = pathInfo.getPath();
        if (requestedPath != null) {
            List<PathElem> pathElems = path.getPathElems();  // existing pathElems to be removed
            List<PathElem> removePathElems = new ArrayList<PathElem>();  //new pathElems to be added
            if (!pathElems.isEmpty()){
                // remove pathElems and pathElemsParams
                PathElemDAO peDAO = new PathElemDAO(dbname);
                PathElemParamDAO  pepDAO = new PathElemParamDAO(dbname);
                for (PathElem pe : pathElems) {
                    ArrayList<PathElemParam> paramsCopy = new ArrayList<PathElemParam>();
                    //copy elemParams to avoid ConcurrentMod exception
                    for ( PathElemParam pep : pe.getPathElemParams()) {
                        paramsCopy.add(pep);
                    }
                    for ( PathElemParam pep : paramsCopy) {
                        pe.removePathElemParam(pep);
                        pepDAO.remove(pep);
                    }
                    peDAO.remove(pe);
                    removePathElems.add(pe);
                } 
                pathElems.removeAll(removePathElems);
            }
            List<CtrlPlaneHopContent> hops = requestedPath.getHop(); 
            for ( Iterator<CtrlPlaneHopContent> hopIter = hops.iterator(); hopIter.hasNext();){
                CtrlPlaneHopContent hop = hopIter.next();
                PathElem pathElem = new PathElem();
                CtrlPlaneLinkContent link = hop.getLink();
                if (link != null) {
                    List<PathElemParam> pathElemParams =
                        convertCtrlPlaneLink(link);
                    for (PathElemParam pep: pathElemParams) {
                        pathElem.addPathElemParam(pep);
                    }
                }else if ((hopIter.hasNext() == false)  && layer2Info != null &&
                        layer2Info.getDestVtag() != null){
                    /* if last hop is a linkIdRef then copy
                   dest VLAN params. This is for compatibility
                   with 0.4 */
                    PathElemParam pathElemParam = new PathElemParam();
                    pathElemParam.setSwcap(PathElemParamSwcap.L2SC);
                    pathElemParam.setType(PathElemParamType.L2SC_VLAN_RANGE);
                    // I changed the following code to correspond to the new fields in vlanTag- mrt
                    pathElemParam.setValue(layer2Info.getDestVtag().isTagged() ?
                            layer2Info.getDestVtag().getValue() : "0");
                    pathElem.addPathElemParam(pathElemParam);
                }
                String urn = hopToURN(hop, "any");
                pathElem.setUrn(urn);
                pathElems.add(pathElem);
            }
            path.setPathElems(pathElems);
        }
        //log.debug("updatePath.end");
    }
    /**
     * 
     * @param link
     * @return List<PathElemsParams> describing the link's capability
     */
    public static List<PathElemParam> convertCtrlPlaneLink(CtrlPlaneLinkContent link) {

    List<PathElemParam> pathElemParams = new ArrayList<PathElemParam>();
    // Assume there is one and only one ISCD
    for (CtrlPlaneSwcapContent swcap: link.getSwitchingCapabilityDescriptors()) {
        String switchingcapType = swcap.getSwitchingcapType();
        CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = 
                            swcap.getSwitchingCapabilitySpecificInfo();
        if(switchingcapType == null || "".equals(switchingcapType.trim())){
          //TODO: should esnet change its topology so these are set and we can throw an exception?
            switchingcapType = DEFAULT_SWCAP;
        }
        if(swcap.getEncodingType() == null || "".equals(swcap.getEncodingType().trim())){
          //TODO: should esnet change its topology so these are set and we can throw an exception?
            swcap.setEncodingType(DEFAULT_ENCODING);
        }
        PathElemParam encodingParam = new PathElemParam();
        encodingParam.setSwcap(switchingcapType);
        encodingParam.setType(PathElemParamType.ENCODING_TYPE);
        encodingParam.setValue(swcap.getEncodingType());
        pathElemParams.add(encodingParam);

        if (swcapInfo.getVlanRangeAvailability() != null) {
            PathElemParam pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType(PathElemParamType.L2SC_VLAN_RANGE);
            pathElemParam.setValue(swcapInfo.getVlanRangeAvailability());
            pathElemParams.add(pathElemParam);
        }
        if (swcapInfo.getSuggestedVLANRange() != null) {
            PathElemParam pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType(PathElemParamType.L2SC_SUGGESTED_VLAN);
            pathElemParam.setValue(swcapInfo.getSuggestedVLANRange());
            pathElemParams.add(pathElemParam);
        }
        // ARCHSTONE: pscSpecificInfo
        if (swcapInfo.getPscSpecificInfo() != null) {
            PathElemParam pathElemParam;
            if (swcapInfo.getPscSpecificInfo().getInterfaceMTU() > 0) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.INTERFACE_MTU);
                pathElemParam.setValue(Integer.toString(swcapInfo.getPscSpecificInfo().getInterfaceMTU()));
                pathElemParams.add(pathElemParam);
            }
            if (swcapInfo.getPscSpecificInfo().getLspHierarchy() != null 
                    && !swcapInfo.getPscSpecificInfo().getLspHierarchy().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.LSP_HIERARCHY);
                pathElemParam.setValue(swcapInfo.getPscSpecificInfo().getLspHierarchy());
                pathElemParams.add(pathElemParam);
            }
            
        }
        // ARCHSTONE: l2scSpecificInfo
        if (swcapInfo.getL2ScSpecificInfo() != null) {
            PathElemParam pathElemParam;
            if (swcapInfo.getL2ScSpecificInfo().getInterfaceMTU() > 0) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.INTERFACE_MTU);
                pathElemParam.setValue(Integer.toString(swcapInfo.getL2ScSpecificInfo().getInterfaceMTU()));
                pathElemParams.add(pathElemParam);
            }
            if (swcapInfo.getL2ScSpecificInfo().getVlanRangeSet() != null 
                    && !swcapInfo.getL2ScSpecificInfo().getVlanRangeSet().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.VLAN_RANGE_SET);
                pathElemParam.setValue(swcapInfo.getL2ScSpecificInfo().getVlanRangeSet());
                pathElemParams.add(pathElemParam);
            }
            if (swcapInfo.getL2ScSpecificInfo().getSuggestedVlanSet() != null 
                    && !swcapInfo.getL2ScSpecificInfo().getSuggestedVlanSet().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.SUGGESTED_VLAN_SET);
                pathElemParam.setValue(swcapInfo.getL2ScSpecificInfo().getSuggestedVlanSet());
                pathElemParams.add(pathElemParam);
            }
            pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType(PathElemParamType.VLAN_TRANSLATION);
            pathElemParam.setValue(swcapInfo.getL2ScSpecificInfo().isVlanTranslation() ? "true":"false");
            pathElemParams.add(pathElemParam);
        }
        // ARCHSTONE: tdmSpecificInfo
        if (swcapInfo.getTdmSpecificInfo() != null) {
            PathElemParam pathElemParam;
            if (swcapInfo.getTdmSpecificInfo().getTimeslotRangeSet() != null 
                    && !swcapInfo.getTdmSpecificInfo().getTimeslotRangeSet().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.TIMESLOT_RANGE_SET);
                pathElemParam.setValue(swcapInfo.getTdmSpecificInfo().getTimeslotRangeSet());
                pathElemParams.add(pathElemParam);
            }
            if (swcapInfo.getTdmSpecificInfo().getSuggestedTimeslotSet() != null 
                    && !swcapInfo.getTdmSpecificInfo().getSuggestedTimeslotSet().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.SUGGESTED_TIMESLOT_SET);
                pathElemParam.setValue(swcapInfo.getTdmSpecificInfo().getSuggestedTimeslotSet());
                pathElemParams.add(pathElemParam);
            }
            pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType(PathElemParamType.TSI_ENABLED);
            pathElemParam.setValue(swcapInfo.getTdmSpecificInfo().isTsiEnabled() ? "true":"false");
            pathElemParams.add(pathElemParam);
            pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType(PathElemParamType.VCAT_ENABLED);
            pathElemParam.setValue(swcapInfo.getTdmSpecificInfo().isVcatEnabled() ? "true":"false");
            pathElemParams.add(pathElemParam);
        }
        // ARCHSTONE: lscSpecificInfo
        if (swcapInfo.getLscSpecificInfo() != null) {
            PathElemParam pathElemParam;
            if (swcapInfo.getLscSpecificInfo().getWavelengthRangeSet() != null 
                    && !swcapInfo.getLscSpecificInfo().getWavelengthRangeSet().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.WAVELENGTH_RANGE_SET);
                pathElemParam.setValue(swcapInfo.getLscSpecificInfo().getWavelengthRangeSet());
                pathElemParams.add(pathElemParam);
            }
            if (swcapInfo.getLscSpecificInfo().getSuggestedWavelengthSet() != null 
                    && !swcapInfo.getLscSpecificInfo().getSuggestedWavelengthSet().isEmpty()) {
                pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.SUGGESTED_WAVELENGTH_SET);
                pathElemParam.setValue(swcapInfo.getLscSpecificInfo().getSuggestedWavelengthSet());
                pathElemParams.add(pathElemParam);
            }
            pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType(PathElemParamType.WAVELENGTH_CONVERSION);
            pathElemParam.setValue(swcapInfo.getLscSpecificInfo().isWavelengthConversionEnabled() ? "true":"false");
            pathElemParams.add(pathElemParam);
        }
        // ARCHSTONE: openflowSpecificInfo
        if (swcapInfo.getOpenflowSpecificInfo() != null) {
            // TODO: OpenFlow schema not finalized
        }
        if (swcapInfo.getVendorSpecificInfo() != null) {
            // Marshall swcapInfo.getVendorSpecificInfo() into XML
            try {
                PathElemParam pathElemParam = new PathElemParam();
                pathElemParam.setSwcap(switchingcapType);
                pathElemParam.setType(PathElemParamType.VENDOR_SPECIFIC_INFO);
                    Document infoDoc = null;
                    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
                    dbf.setNamespaceAware(false);
                    DocumentBuilder db = dbf.newDocumentBuilder();
                    infoDoc = db.newDocument();
                    JAXBContext jc = JAXBContext.newInstance("org.ogf.schema.network.topology.ctrlplane");
                    Marshaller m = jc.createMarshaller();
                    m.marshal(swcapInfo.getVendorSpecificInfo().getInfineraDTNSpecificInfo(), infoDoc);
                    TransformerFactory factory = TransformerFactory.newInstance();
                    Transformer transformer = factory.newTransformer();
                    StringWriter writer = new StringWriter();
                    Result result = new StreamResult(writer);
                    Source source = new DOMSource(infoDoc);
                    transformer.transform(source, result);
                    writer.close();
                    pathElemParam.setValue(writer.toString());
                    pathElemParams.add(pathElemParam);
            } catch (Exception e) {
                    //throw new RMException("Error marshling InfineraDTNSpecificInfo " + e.getMessage());
            }
        }
    }

    if (link.getAdjustmentCapabilityDescriptor().size() > 0) {
        CtrlPlaneAdcapContent adjcap = link.getAdjustmentCapabilityDescriptor().get(0);
        PathElemParam pathElemParam = new PathElemParam();
        pathElemParam.setSwcap(PathElemParamSwcap.ADJUST);
        pathElemParam.setType(PathElemParamType.LOWER_SWCAP);
        pathElemParam.setValue(adjcap.getLowerSwcap());
        pathElemParams.add(pathElemParam);
        pathElemParam = new PathElemParam();
        pathElemParam.setSwcap(PathElemParamSwcap.ADJUST);
        pathElemParam.setType(PathElemParamType.LOWER_ENC_TYPE);
        pathElemParam.setValue(adjcap.getLowerEncType());
        pathElemParams.add(pathElemParam);
        pathElemParam = new PathElemParam();
        pathElemParam.setSwcap(PathElemParamSwcap.ADJUST);
        pathElemParam.setType(PathElemParamType.UPPER_SWCAP);
        pathElemParam.setValue(adjcap.getUpperSwcap());
        pathElemParams.add(pathElemParam);
        pathElemParam = new PathElemParam();
        pathElemParam.setSwcap(PathElemParamSwcap.ADJUST);
        pathElemParam.setType(PathElemParamType.UPPER_ENC_TYPE);
        pathElemParam.setValue(adjcap.getUpperEncType());
        pathElemParams.add(pathElemParam);
        if (adjcap.getMaximumAdjustableCapacity() != null
                && !adjcap.getMaximumAdjustableCapacity().isEmpty()) {
            pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(PathElemParamSwcap.ADJUST);
            pathElemParam.setType(PathElemParamType.MAX_ADJUST_CAPACITY);
            pathElemParam.setValue(adjcap.getMaximumAdjustableCapacity());
            pathElemParams.add(pathElemParam);
        }
    }
    return pathElemParams;
}
    /**
     * Converts soap Layer2Info object to a Layer2Data Hibernate bean
     *
     * @param layer2Info the Layer2Info object to convert
     * @return the converted Layer2Data bean
     */
     public static Layer2Data layer2InfoToData(Layer2Info layer2Info){
        if(layer2Info == null){
            return null;
        }
        Layer2Data layer2Data = new Layer2Data();
        layer2Data.setSrcEndpoint(layer2Info.getSrcEndpoint());
        layer2Data.setDestEndpoint(layer2Info.getDestEndpoint());

        return layer2Data;
     }

     /**
      * Updates a persistent Layer2Data object with new contents
      * Assumes all values are input
      * @param layer2Data
      * @param layer2Info
      */
     public static void updateLayer2Data(Layer2Data layer2Data, Layer2Info layer2Info) {
         if(layer2Info == null){
             return;
         }
         //log.debug("updateLayer2.start ");
         layer2Data.setSrcEndpoint(layer2Info.getSrcEndpoint());
         layer2Data.setDestEndpoint(layer2Info.getDestEndpoint());
         //log.debug("updateLayer2.end ");
     }

     /**
     * Converts soap Layer3Info object to a Layer3Data Hibernate bean
     *
     * @param layer3Info the Layer3Info object to convert
     * @return the converted Layer3Data bean
     */
     public static Layer3Data layer3InfoToData(Layer3Info layer3Info){
        if(layer3Info == null){
            return null;
        }
        
        Layer3Data layer3Data = new Layer3Data();

        layer3Data.setSrcHost(layer3Info.getSrcHost());
        layer3Data.setDestHost(layer3Info.getDestHost());
        layer3Data.setSrcIpPort(layer3Info.getSrcIpPort());
        layer3Data.setDestIpPort(layer3Info.getDestIpPort());
        layer3Data.setProtocol(layer3Info.getProtocol());
        layer3Data.setDscp(layer3Info.getDscp());

        return layer3Data;
     }
     /**
      * Updates a persistent Layer3Data object with new contents
      * Assumes all fields are input
      * @param layer3Data
      * @param layer3Info
      */
     public static void updateLayer3Data(Layer3Data layer3Data, Layer3Info layer3Info) {
         if(layer3Info == null){
             return;
         } 
         //log.debug("updateLayer3Data.start");
         layer3Data.setSrcHost(layer3Info.getSrcHost());
         layer3Data.setDestHost(layer3Info.getDestHost());
         layer3Data.setSrcIpPort(layer3Info.getSrcIpPort());
         layer3Data.setDestIpPort(layer3Info.getDestIpPort());
         layer3Data.setProtocol(layer3Info.getProtocol());
         layer3Data.setDscp(layer3Info.getDscp());
         //log.debug("updateLayer3Data.end");
     }
     /**
     * Converts soap MplsInfo object to a MPLSData Hibernate bean
     *
     * @param mplsInfo the MplsInfo object to convert
     * @return the converted MPLSData bean
     */
     public static MPLSData mplsInfoToData(MplsInfo mplsInfo){
        if(mplsInfo == null){
            return null;
        }
        MPLSData mplsData = new MPLSData();

        mplsData.setBurstLimit((long) mplsInfo.getBurstLimit());
        mplsData.setLspClass(mplsInfo.getLspClass());

        return mplsData;
     }

     /**
      * update a persistent mplsData object with new values
      * Assume both values are input
      * @param mplsData
      * @param mplsInfo
      */
     public static void updateMplsData(MPLSData mplsData, MplsInfo mplsInfo){
         if(mplsInfo == null){
             return;
         }
         //log.debug("updateMplsData.start");
         mplsData.setBurstLimit((long) mplsInfo.getBurstLimit());
         mplsData.setLspClass(mplsInfo.getLspClass());
         //log.debug("updateMplsData.end");
     }
     
     public static PathElem addDefaultPathElem(String hop, VlanTag vtag) {
         PathElem pe = new PathElem();
         pe.setUrn(hop);
         PathElemParam pep = new PathElemParam();
         pep.setSwcap(PathElemParamSwcap.L2SC);
         pep.setType(PathElemParamType.L2SC_VLAN_RANGE);
         String vlan = "any";
         if (vtag != null) {
             vlan = vtag.getValue();
             Boolean tagged = vtag.isTagged();
             if (tagged == null ){
                 System.out.println("vlan.tagged is  null");
             }
             if ((tagged != null) && (tagged != true)) {
                 vlan = "0";
             }
         }
         pep.setValue(vlan);
         pe.addPathElemParam(pep);
         return pe;
     }
     /**
      * Returns the URN of the given type based on the hop object ID or
      * IDRef field. Also does some validation soap is missing.
      *
      * @param hop the CtrlPlaneHopContent to parse
      * @param type string with type of hop
      * @return the domain,node,port or link URN of the hop, null if invalid hop
      */

     public static String hopToURN(CtrlPlaneHopContent hop, String type){
         if(hop == null){
             return null;
         }
         if(type == null || !("link".equals(type) || "any".equals(type) ||
            "port".equals(type) || "node".equals(type) || "domain".equals(type))){
             return null;
         }
         String urn = null;
         int urnType = 0;
         int childCount = 0;

         String linkIdRef = hop.getLinkIdRef();
         if(linkIdRef != null){
             urn = linkIdRef;
             urnType = 1;
             childCount++;
         }
         CtrlPlaneLinkContent link = hop.getLink();
         if(link != null){
             urn = link.getId();
             urnType = 1;
             childCount++;
         }
         if("link".equals(type)){
             return urn;
         }

         String portIdRef = hop.getPortIdRef();
         if(portIdRef != null){
             urn = portIdRef;
             urnType = 2;
             childCount++;
         }
         CtrlPlanePortContent port = hop.getPort();
         if(port != null){
             urn = port.getId();
             urnType = 2;
             childCount++;
         }
         if("port".equals(type)){
             return urn;
         }

         String nodeIdRef = hop.getNodeIdRef();
         if(nodeIdRef != null){
             urn = nodeIdRef;
             urnType = 3;
             childCount++;
         }
         CtrlPlaneNodeContent node = hop.getNode();
         if(node != null){
             urn = node.getId();
             urnType = 3;
             childCount++;
         }
         if("node".equals(type)){
             return urn;
         }

         String domainIdRef = hop.getDomainIdRef();
         if(domainIdRef != null){
             urn = domainIdRef;
             urnType = 4;
             childCount++;
         }
         CtrlPlaneDomainContent domain = hop.getDomain();
         if(domain != null){
             urn = domain.getId();
             urnType = 4;
             childCount++;
         }
         if("domain".equals(type)){
             return urn;
         }

         // we have to tcheck errors ourselves because xsd:choice
         //  elements are clunky in Axis2
         if(urn == null){
             log.debug("Empty hop");
         }else if(childCount > 1){
             log.debug("Parse error: Hop must contain only one " +
                            "domain, node, port or link object/reference");
             urn = null;
         }
         return urn;
     }

     /**
      * Builds all components of soap PathInfo structure, given a
      * Hibernate Reservation bean.
      *
      * @param constraint
      * @param path
      * @param internalPathAuthorized
      * @param localDomain
      * @return pathInfo a filled in PathInfo soap type
      */

     public static PathInfo path2PathInfo(StdConstraint constraint,
                                        Path path,
                                        boolean internalPathAuthorized,
                                        String localDomain)
             throws RMException {

         //log.debug("path2PathInfo.start");
         PathInfo pathInfo = new PathInfo();

         if (path != null) {
             pathInfo.setPathSetupMode(path.getPathSetupMode());
             pathInfo.setPathType(path.getPathType());
             pathInfo.setPath(pathToCtrlPlane(constraint,
                                              internalPathAuthorized,
                                              localDomain));
             // one of these is allowed to be null
             Layer2Info layer2Info = pathToLayer2Info(path);
             pathInfo.setLayer2Info(layer2Info);
             Layer3Info layer3Info = pathToLayer3Info(path);
             pathInfo.setLayer3Info(layer3Info);
             // allowed to be null
             MplsInfo mplsInfo = pathToMplsInfo(path);
             pathInfo.setMplsInfo(mplsInfo);
             //log.debug("path2PathInfo.end");
             return pathInfo;
         } else {
             return pathInfo;
             //throw new RMException("path: " + pathType + " does not exist");
         }
     }

     /**
      * Builds soap CtrlPlanePathContent, given Hibernate Reservation bean with
      * information retrieved from database.  The path is built up given a set
      * of paths and the user's authorization.  If any type of path contains
      * internal hops to the local domain, for example a requested path, and
      * the user viewing the reservation is not authorized, the internal hops
      * are not returned.  If the user is authorized and both the local and
      * interdomain paths exist, the paths are combined and returned.
      *
      * @param constraint contains the path to be converted to a CtrlPlanePathContent type
      * @param internalPathAuthorized boolean indicating whether internal hops viewable
      * @param localDomain String with id of local domain
      * @return A CtrlPlanePathContent instance
      * @throws RMException 
      */

     public static CtrlPlanePathContent
         pathToCtrlPlane(StdConstraint constraint, 
                         boolean internalPathAuthorized, String localDomain)
             throws RMException {

         //log.debug("pathToCtrlPlane.start");
         Path path = constraint.getPath();
         List<PathElem> pathElems = path.getPathElems();
         CtrlPlanePathContent ctrlPlanePath = new CtrlPlanePathContent();
         List<Boolean> isLocalHop = new ArrayList<Boolean>();
         int ctr = 1;

         for (PathElem pathElem: pathElems) {
             CtrlPlaneHopContent hop =
                 WSDLTypeConverter.convertHop(pathElem, ctr, localDomain,
                                              isLocalHop);
             ctrlPlanePath.getHop().add(hop);
             ctr++;
         }

         // if not set, ignore authorization check 
         if (localDomain == null) {
             ctrlPlanePath.setId("unimplemented");
             return ctrlPlanePath;
         }
         if (!internalPathAuthorized) {
             ctrlPlanePath =
                 WSDLTypeConverter.removeInternalHops(ctrlPlanePath,
                                                      isLocalHop);
         } 

         ctrlPlanePath.setId("unimplemented");
         //log.debug("pathToCtrlPlane.end");
         return ctrlPlanePath;
     }


     /**
      * Fills in soap CtrlPlaneHopContent, given a Hibernate PathElem bean.
      * @param pathElem Hibernate PathElem instance
      * @param ctr hop number
      * @param isLocalHop list whose element indicates whether hop is in the local domain
      * @return A CtrlPlaneHopContent instance
      * @throws RMException 
      */

     public static CtrlPlaneHopContent
         convertHop(PathElem pathElem, int ctr, String localDomain,
                    List<Boolean> isLocalHop)
             throws RMException {

         //log.debug("convertHop.start");
         CtrlPlaneHopContent hop = new CtrlPlaneHopContent();
         String urn = pathElem.getUrn();

         Hashtable<String, String> parseResults = URNParser.parseTopoIdent(urn);
         // if null, isLocalHop ignored in calling method
         if (localDomain != null) {
             String hopDomain = parseResults.get("domainId");
             if ((hopDomain != null) && !hopDomain.equals("")) {
                 if (hopDomain.equals(localDomain)) {
                     isLocalHop.add(Boolean.TRUE);
                 } else {
                     isLocalHop.add(Boolean.FALSE);
                 }
             } else {  // this shouldn't happen
                 isLocalHop.add(Boolean.FALSE);
             }
         }

         String hopType = parseResults.get("type");
         hop.setId(ctr + "");
             
         // Handle case where unconfirmed path contains domain, node, 
         // port, or link id refs 
         if ("domain".equals(hopType)) {
             hop.setDomainIdRef(urn);
         } else if("node".equals(hopType)) {
             hop.setNodeIdRef(urn);
         } else if("port".equals(hopType)) {
             hop.setPortIdRef(urn);
         } else if ("link".equals(hopType) && pathElem.getPathElemParams().isEmpty()) {
             // if nor pathElem params then just set an idRef
             hop.setLinkIdRef(urn);
         } else if ("link".equals(hopType)){
             CtrlPlaneLinkContent link = new CtrlPlaneLinkContent();
             link.setId(urn);             
             //get supported swcap type
             HashMap<String,Boolean> swcaps = new HashMap<String,Boolean>();
             for(PathElemParam pathElemParam : pathElem.getPathElemParams()){
                 swcaps.put(pathElemParam.getSwcap(), true);
             }             
             //add swcap parameters
             if(swcaps.containsKey(PathElemParamSwcap.MPLS)){ // backward compatible with pre-ARCHSTONE
                 CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
                 CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                 swcap.setSwitchingcapType(PathElemParamSwcap.MPLS);
                 PathElemParam encodingType = pathElem.getPathElemParam(PathElemParamSwcap.MPLS, PathElemParamType.ENCODING_TYPE);
                 if(encodingType != null){
                     swcap.setEncodingType(encodingType.getValue());
                 }
                 PathElemParam vlanRange = pathElem.getPathElemParam(PathElemParamSwcap.MPLS, PathElemParamType.MPLS_VLAN_RANGE);
                 if(vlanRange != null){
                     swcapInfo.setVlanRangeAvailability(vlanRange.getValue());
                 }
                 PathElemParam suggVlanRange = pathElem.getPathElemParam(PathElemParamSwcap.MPLS, PathElemParamType.MPLS_SUGGESTED_VLAN);
                 if(suggVlanRange != null){
                     swcapInfo.setSuggestedVLANRange(suggVlanRange.getValue());
                 }
                 swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                 link.getSwitchingCapabilityDescriptors().add(swcap);
             } else if(swcaps.containsKey(PathElemParamSwcap.PSC)){
                 CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
                 CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                 CtrlPlaneSwitchingCapabilitySpecificInfoPsc pscInfo = new CtrlPlaneSwitchingCapabilitySpecificInfoPsc();
                 swcap.setSwitchingcapType(PathElemParamSwcap.PSC);
                 PathElemParam encodingType = pathElem.getPathElemParam(PathElemParamSwcap.PSC, PathElemParamType.ENCODING_TYPE);
                 if(encodingType != null){
                     swcap.setEncodingType(encodingType.getValue());
                 }
                 PathElemParam interfaceMTU = pathElem.getPathElemParam(PathElemParamSwcap.PSC, PathElemParamType.INTERFACE_MTU);
                 if(interfaceMTU != null){
                     pscInfo.setInterfaceMTU(Integer.getInteger(interfaceMTU.getValue()));
                 }
                 PathElemParam lspHierarchy = pathElem.getPathElemParam(PathElemParamSwcap.PSC, PathElemParamType.LSP_HIERARCHY);
                 if(lspHierarchy != null){
                     pscInfo.setLspHierarchy(lspHierarchy.getValue());
                 }
                 PathElemParam vendorSpecificInfo = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.VENDOR_SPECIFIC_INFO);
                 if (vendorSpecificInfo != null) {
                     swcapInfo.setVendorSpecificInfo(convertVendorSpecificInfo(vendorSpecificInfo.getValue()));
                 }
                 swcapInfo.setPscSpecificInfo(pscInfo);
                 swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                 link.getSwitchingCapabilityDescriptors().add(swcap);
             } else if(swcaps.containsKey(PathElemParamSwcap.L2SC)){
                 CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
                 CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                 swcap.setSwitchingcapType(PathElemParamSwcap.L2SC);
                 PathElemParam encodingType = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.ENCODING_TYPE);
                 if(encodingType != null){
                     swcap.setEncodingType(encodingType.getValue());
                 }
                 PathElemParam vlanRange = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.L2SC_VLAN_RANGE);
                 if(vlanRange != null){
                     swcapInfo.setVlanRangeAvailability(vlanRange.getValue());
                 }
                 PathElemParam suggVlanRange = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.L2SC_SUGGESTED_VLAN);
                 if(suggVlanRange != null){
                     swcapInfo.setSuggestedVLANRange(suggVlanRange.getValue());
                 }
                 if (pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.VLAN_RANGE_SET) != null) {
                     CtrlPlaneSwitchingCapabilitySpecificInfoL2Sc l2scInfo = new CtrlPlaneSwitchingCapabilitySpecificInfoL2Sc();
                     PathElemParam vlanRangeSet = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.VLAN_RANGE_SET);
                     if(vlanRangeSet != null){
                         l2scInfo.setVlanRangeSet(vlanRangeSet.getValue());
                     }
                     PathElemParam suggestedVlanSet = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.SUGGESTED_VLAN_SET);
                     if(suggestedVlanSet != null){
                         l2scInfo.setSuggestedVlanSet(suggestedVlanSet.getValue());
                     }
                     PathElemParam vlanTranslation = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.VLAN_TRANSLATION);
                     if(vlanTranslation != null){
                         l2scInfo.setVlanTranslation(vlanTranslation.getValue().contains("true") ? true : false);
                     }
                     PathElemParam vendorSpecificInfo = pathElem.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.VENDOR_SPECIFIC_INFO);
                     if (vendorSpecificInfo != null) {
                         swcapInfo.setVendorSpecificInfo(convertVendorSpecificInfo(vendorSpecificInfo.getValue()));
                     }
                     swcapInfo.setL2ScSpecificInfo(l2scInfo);
                 }
                 swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                 link.getSwitchingCapabilityDescriptors().add(swcap);
             } else if(swcaps.containsKey(PathElemParamSwcap.TDM)){
                 CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
                 CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                 swcap.setSwitchingcapType(PathElemParamSwcap.TDM);
                 PathElemParam encodingType = pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.ENCODING_TYPE);
                 if(encodingType != null){
                     swcap.setEncodingType(encodingType.getValue());
                 }
                 if (pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.TIMESLOT_RANGE_SET) != null) {
                     CtrlPlaneSwitchingCapabilitySpecificInfoTdm tdmInfo = new CtrlPlaneSwitchingCapabilitySpecificInfoTdm();
                     PathElemParam timeslotRangeSet = pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.TIMESLOT_RANGE_SET);
                     if(timeslotRangeSet != null){
                         tdmInfo.setTimeslotRangeSet(timeslotRangeSet.getValue());
                     }
                     PathElemParam suggestedTimeslotSet = pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.SUGGESTED_TIMESLOT_SET);
                     if(suggestedTimeslotSet != null){
                         tdmInfo.setSuggestedTimeslotSet(suggestedTimeslotSet.getValue());
                     }
                     PathElemParam tsiEnabled = pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.TSI_ENABLED);
                     if(tsiEnabled != null){
                         tdmInfo.setTsiEnabled(tsiEnabled.getValue().contains("true") ? true : false);
                     }
                     PathElemParam vcatEnabled = pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.VCAT_ENABLED);
                     if(vcatEnabled != null){
                         tdmInfo.setTsiEnabled(vcatEnabled.getValue().contains("true") ? true : false);
                     }
                     PathElemParam vendorSpecificInfo = pathElem.getPathElemParam(PathElemParamSwcap.TDM, PathElemParamType.VENDOR_SPECIFIC_INFO);
                     if (vendorSpecificInfo != null) {
                         swcapInfo.setVendorSpecificInfo(convertVendorSpecificInfo(vendorSpecificInfo.getValue()));
                     }
                     swcapInfo.setTdmSpecificInfo(tdmInfo);
                 }
                 swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                 link.getSwitchingCapabilityDescriptors().add(swcap);
             } else if(swcaps.containsKey(PathElemParamSwcap.LSC)){
                 CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
                 CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                 swcap.setSwitchingcapType(PathElemParamSwcap.LSC);
                 PathElemParam encodingType = pathElem.getPathElemParam(PathElemParamSwcap.LSC, PathElemParamType.ENCODING_TYPE);
                 if(encodingType != null){
                     swcap.setEncodingType(encodingType.getValue());
                 }
                 CtrlPlaneSwitchingCapabilitySpecificInfoLsc lscInfo = new CtrlPlaneSwitchingCapabilitySpecificInfoLsc();
                 PathElemParam wavelengthRangeSet = pathElem.getPathElemParam(PathElemParamSwcap.LSC, PathElemParamType.WAVELENGTH_RANGE_SET);
                 if (wavelengthRangeSet != null) {
                     lscInfo.setWavelengthRangeSet(wavelengthRangeSet.getValue());
                 }
                 PathElemParam suggestedWavelengthSet = pathElem.getPathElemParam(PathElemParamSwcap.LSC, PathElemParamType.SUGGESTED_WAVELENGTH_SET);
                 if (suggestedWavelengthSet != null) {
                     lscInfo.setSuggestedWavelengthSet(suggestedWavelengthSet.getValue());
                 }
                 PathElemParam wavelengthConversion = pathElem.getPathElemParam(PathElemParamSwcap.LSC, PathElemParamType.WAVELENGTH_CONVERSION);
                 if (wavelengthConversion != null) {
                     lscInfo.setWavelengthConversionEnabled(wavelengthConversion.getValue().contains("true") ? true : false);
                 }
                 PathElemParam vendorSpecificInfo = pathElem.getPathElemParam(PathElemParamSwcap.LSC, PathElemParamType.VENDOR_SPECIFIC_INFO);
                 if (vendorSpecificInfo != null) {
                     swcapInfo.setVendorSpecificInfo(convertVendorSpecificInfo(vendorSpecificInfo.getValue()));
                 }
                 swcapInfo.setLscSpecificInfo(lscInfo);                 
                 swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                 link.getSwitchingCapabilityDescriptors().add(swcap);
             } else if(swcaps.containsKey(PathElemParamSwcap.OPENFLOW)){
                 CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
                 CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                 swcap.setSwitchingcapType(PathElemParamSwcap.OPENFLOW);
                 PathElemParam encodingType = pathElem.getPathElemParam(PathElemParamSwcap.OPENFLOW, PathElemParamType.ENCODING_TYPE);
                 if(encodingType != null){
                     swcap.setEncodingType(encodingType.getValue());
                 }
                 // TODO: OpenFlow schema not finalized yet
                 swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                 link.getSwitchingCapabilityDescriptors().add(swcap);
             } else if(swcaps.containsKey(PathElemParamSwcap.ADJUST)){
                 CtrlPlaneAdcapContent adcap = new CtrlPlaneAdcapContent();
                 PathElemParam lowerSwcap = pathElem.getPathElemParam(PathElemParamSwcap.ADJUST, PathElemParamType.LOWER_SWCAP);
                 if(lowerSwcap != null){
                     adcap.setLowerSwcap(lowerSwcap.getValue());
                 }
                 PathElemParam lowerEncType = pathElem.getPathElemParam(PathElemParamSwcap.ADJUST, PathElemParamType.LOWER_ENC_TYPE);
                 if(lowerEncType != null){
                     adcap.setLowerEncType(lowerEncType.getValue());
                 }
                 PathElemParam upperSwcap = pathElem.getPathElemParam(PathElemParamSwcap.ADJUST, PathElemParamType.UPPER_SWCAP);
                 if(upperSwcap != null){
                     adcap.setLowerSwcap(upperSwcap.getValue());
                 }
                 PathElemParam upperEncType = pathElem.getPathElemParam(PathElemParamSwcap.ADJUST, PathElemParamType.UPPER_ENC_TYPE);
                 if(upperEncType != null){
                     adcap.setLowerEncType(upperEncType.getValue());
                 }
                 // TODO: handle adjustSpecificInfo
                 link.getAdjustmentCapabilityDescriptor().add(adcap);
             }
             hop.setLink(link);
         }
         
         //log.debug("convertHop.end");
         return hop;
     }

     public static CtrlPlaneSwcapVendorSpecificInfo 
             convertVendorSpecificInfo(String xmlString) throws RMException{
         // Unmarshall swcapInfo.vendorSpecificInfo from XML
         CtrlPlaneSwcapVendorSpecificInfo vendorSpecificInfo = new CtrlPlaneSwcapVendorSpecificInfo();
         try {
             Document infoDoc = null;
             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
             dbf.setNamespaceAware(false);
             DocumentBuilder db = dbf.newDocumentBuilder();
             infoDoc = db.newDocument();
             JAXBContext jc = JAXBContext.newInstance("org.ogf.schema.network.topology.ctrlplane");
             Unmarshaller unm = jc.createUnmarshaller();
             StringReader reader = new StringReader(xmlString);
             JAXBElement<CtrlPlaneSwcapVendorSpecificInfo> jaxbVendorSpecificInfo = (JAXBElement<CtrlPlaneSwcapVendorSpecificInfo>)unm.unmarshal(reader);
             vendorSpecificInfo = jaxbVendorSpecificInfo.getValue();
             reader.close();
             return vendorSpecificInfo;
         } catch (Exception e) {
             throw new RMException("Error unmarshling InfineraDTNSpecificInfo " + e.getMessage() + " xmlString=" + xmlString);
         }
    }

     /**
      * Remove hops internal to domain, leaving ingress and egress.
      * @param ctrlPlanePath CtrlPlanePathContent with path
      * @param isLocalHop list of booleans with whether corresponding hop is local to domain
      * @return CtrlPlanePathContent newPath path with internal hops removed
      */
     public static CtrlPlanePathContent
         removeInternalHops(CtrlPlanePathContent ctrlPlanePath,
                            List<Boolean> isLocalHop) {

         CtrlPlanePathContent newPath = new CtrlPlanePathContent();
         List<CtrlPlaneHopContent> hops = ctrlPlanePath.getHop();
         for (int i = 0; i < hops.size(); i++) {
             if ((i > 0) && (i < (hops.size()-1))) {
                 if (!isLocalHop.get(i-1) || !isLocalHop.get(i+1)) {
                     newPath.getHop().add(hops.get(i));
                 }
             } else {
                 newPath.getHop().add(hops.get(i));
             }
         }
         return newPath;
     }

     
     /**
      * Given the Hibernate bean for a path, return a filled in soap instance
      * for layer 2 information.
      */
     public static Layer2Info pathToLayer2Info(Path path) {
         //log.debug("pathToLayer2Info.start");
         // database type
         Layer2Data layer2Data = path.getLayer2Data();
         if (layer2Data == null) {
             return null;
         }

         // soap type
         Layer2Info layer2Info = new Layer2Info();
         layer2Info.setSrcEndpoint(layer2Data.getSrcEndpoint());
         layer2Info.setDestEndpoint(layer2Data.getDestEndpoint());
         
         //Set source vlan and dest vlan
         if (path.getPathElems() != null && !path.getPathElems().isEmpty()){
             PathElem src = path.getPathElems().get(0);
             try {
                 PathElemParam param = src.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.L2SC_VLAN_RANGE);
                 if (param != null){
                     VlanTag srcVlan = new VlanTag();
                     srcVlan.setTagged(!"0".equals(param.getValue()));
                     srcVlan.setValue(param.getValue());
                     layer2Info.setSrcVtag(srcVlan);
                 }
             } catch (RMException e) {}
             
             PathElem dest = path.getPathElems().get(path.getPathElems().size() -1);
             try {
                 PathElemParam param = dest.getPathElemParam(PathElemParamSwcap.L2SC, PathElemParamType.L2SC_VLAN_RANGE);
                 if(param != null){
                     VlanTag destVlan = new VlanTag();
                     destVlan.setTagged(!"0".equals(param.getValue()));
                     destVlan.setValue(param.getValue());
                     layer2Info.setDestVtag(destVlan);
                 }
             } catch (RMException e) {}
         }
        //log.debug("pathToLayer2Info.end");
         return layer2Info;
     }

     /**
      * Given the Hibernate bean for a path, return a filled in soap instance
      * for layer 3 information.
      */
     public static Layer3Info pathToLayer3Info(Path path) {
        // log.debug("pathToLayer3Info.start");

         // database type
         Layer3Data layer3Data = path.getLayer3Data();
         if (layer3Data == null) {
             return null;
         }
         // soap type
         Layer3Info layer3Info = new Layer3Info();
         layer3Info.setSrcHost(layer3Data.getSrcHost());
         layer3Info.setDestHost(layer3Data.getDestHost());
         // makes sure that protocol is in upper case to match WSDL
         if (layer3Data.getProtocol() != null) {
             layer3Info.setProtocol(layer3Data.getProtocol().toUpperCase());
         }
         if (layer3Data.getSrcIpPort() != null) {
             layer3Info.setSrcIpPort(layer3Data.getSrcIpPort());
         }
         if (layer3Data.getDestIpPort() != null) {
             layer3Info.setDestIpPort(layer3Data.getDestIpPort());
         }
         //log.debug("pathToLayer3Info.end");

         return layer3Info;
     }

     /**
      * Given the Hibernate bean for a path, return a filled in soap instance
      * for MPLS information.
      */
     public static MplsInfo pathToMplsInfo(Path path) {
        // log.debug("pathToMplsInfo.start");

         // database type
         MPLSData mplsData = path.getMplsData();
         if (mplsData == null) {
             return null;
         }
         // soap type
         MplsInfo mplsInfo = new MplsInfo();
         int burstLimit = mplsData.getBurstLimit().intValue();
         mplsInfo.setBurstLimit(burstLimit);
         mplsInfo.setLspClass(mplsData.getLspClass());
         //log.debug("pathToMplsInfo.end");
         return mplsInfo;
     }


}
